 >> ECE 530 Cloud Computing. Today we're going to discuss about distributed systems. I will say that a lot of the principles we have discussed about Cloud computing is correlated with distributed systems. Today we're going to go a little more in the definition of the correlation between distributed systems and Cloud computing. [NOISE] If we start first of all, defining what is a distributed system, based on the free online dictionary of computing, called FOLDOC. A collection of probably heterogeneous automata whose distribution is transparent to the user so that the system operates as one local machine. This is in contrast to a network where the users are aware that there are several machines, and their location, storage replication, load balancing, and functionality is not transparent. Distributed systems usually use some kind of client-server organization. The question here is Cloud computing and distributed systems based on this definition? The answer is yes, because the customer does not see all the functionality on the machines or the backgrounds, but assumes that this is taken care by a vendor that provides this as a service. Let's have a look at a few more definitions, based on the distributed system is a collection of independent computers that appear to the users of the system as a single computer. With Michael Schroeder, the definition is; distributed systems is several computers doing something together. The distributed system has three primary characteristics: multiple computers, interconnections, and shared state. As we see across the three definitions, what is the distributed system, is something that appears as a single element to the user regardless of the complexity of that. When we try to deal a little more about the problems that we have seen in distributed systems, or that we will observe failure detections, time and synchronization, global state and Snapshots, multicasts communications, mutual exclusion, leader election. All of these are basic theoretical concepts. If we had the time, a distributed systems course will actually focus in all of these elements. However, our focus is on Cloud computing, and a few of the broader aspects is Cloud computing is that of peer-to-peer system. Though some of the elements of Napster, Gnutella, Chord, which is a pretty big systems, are mostly outdated. So Cloud computing, Hadoop, are more correct to what we're doing and what lies beneath those distributed systems is either a network and routing, is a sensor network, or Datacenter disaster case studies. If we see a few of the problems that exist, RPCs or Distributed Objects. These are the basic building blocks that we will see within the Cloud computing area, and distributed services like storage, where we did concurrent control or two-phase COBIT or three-phase COBIT, Paxos is a very famous protocol, and I believe we have the white paper at the end of the course. Replication protocols are very important to achieve, multiple replicas at high availability and gossiping. We will discuss about Cloud computing, some of the elements, key value, SQL stores, and we will cover those later on as well. Stream processing, like data in transit, is also important. There are also some problems of distributed systems that I would say is fairly old, or older Cloud computing like self-stabilization, distributed file systems or distribute shared memory. These are fairly similar distribution problems, but all the steps of the timeline. What is important is when we deal with systems, whether it's Cloud computing or not, is to think about security and Byzantine Fault Tolerance. We will discuss later on in detail about the Byzantine Fault Tolerance. The Distributed System Design Goal is to achieve heterogeneity, robustness, availability, transparency, concurrency, efficiency, scalability, security, and openness, and we'll discuss a few things about consistency, cap theory, partition-tolerance, Acid, Base, and many, many others. Let's go into the definition of these goals. Heterogeneity is different types of servers, of networks, of applications, of services, of consistency guarantees. Now we have different types of many things, whether it's a network, an application of service, consistency guarantees, whatever it is. Robustness is fault-tolerance to a variety of failures. We need to make sure that our system appears as big, robust, regardless of how many services, microservices, or even services that are being used at the background, the system has to be fault-tolerant. Availability of data, of operations, in spite of random failures and network partitions, it is very important. You need to have a notion that this is available for this amount of time. Transparency: provide an abstraction of one property while allowing sufficiently flexibility at run-time, like Clouds, transactions, synchrony, sequential consistency and so forth. Concurrency: support many clients. When you think about Cloud computing, the reason you moved to the Cloud is because you wanted to scale your number of customers or your infrastructure to do that. So concurrency is important is important as an element of many nodes that need a lot of concurrent access. Efficiency: now you need fast, your critical path must be as low as possible in terms of time. If it is really high, then it won't serve the needs of the application itself, and you need to scale your servers to accept a lot of throughput, not only latency but through what's is important. Scalability: many operations per second, in spite of thousands of servers or millions of customers, so you have to scale. Security: system should be protected from attackers and bugs, like encryption and signatures, and is important, because once you give the data to the Cloud, you need to make sure that it is properly secured to achieve the goals. Openness: each service or protocol can be built or other services or protocols, it's layered stack architecture. This is like understanding the system, how it is open, being open about that is very important. We'll discuss about the intricacies of distributors; synchronization, concurrency, failures, and consensus, are the main four properties. Synchronization mean that you need to have multiple clocks, and effectively you need to have multiple nodes, and all of them have to agree to that clock. You will see that this is very, very difficult to achieve, all agree an exact time. Concurrency is when you have different concurrent access, but you need to make sure that if you do have to access, you don't have conflicts or you don't have a different response, based on the access itself. Failures: You have to handle probability of failures. The problem with distributed systems and Cloud computing, is that failures can happen in different spaces like a network partition or multiple simultaneous failures or whatever it is, and you need to make sure that your system is able to operate under any of these random failures. Consensus is difficult to reach consensus, for example, if you have multiple replicas of data, you have to have some sort of consensus, what is the correct information? This has to happen when there is a failure or when there's a lack of synchronization, and even more in [inaudible] What we're trying to do in this lecture is cover the surface of the problems and go really deep into each of them because it's very complicated. In terms of the models, we have a client-server approach, we have a multi-tiered approach, a peer-to-peer approach, an agent-based approach, multiple codes like Applets or mobile agents, service oriented computing, and then we also have Cloud computing. All of these effectively are approaches of a distributed system, or limitations of a distributed system. Then we have the Emerging Computing Model, like the Cloud, the Edge, and Beneath. It's cheaper to provide services to a thin client than it would be to maintain a fat client in a changing world. Effectively, fat clients means that you provide an installable to your machine. For example, when you want to play a game, you install a game on your laptop, or when you install, you install some sort of an application that has all the data. What it says here, is providing a feed client, like a web browser, but you just access something with it, that's the thin client perspective. As we move towards battery limited devices, like mobile phones, and IOT and Edge devices, [NOISE] having a thin client is important because now you remove a lot of the computation from the device back to the Cloud. Besides the Cloud, all other computing infrastructures become simply Edge Devices to the Cloud. The other question is; does IOT count in this new world of Clouds? Or are Sensors Edge Devices? When I'm thinking about that, the case of the Edge, you have effectively the Edge accesses the services in the Cloud. We discussed about Tier 1 and Tier 2. Then you have different types of sensors that do also access those Edge part of the network, and then the services, Tier 1 accesses the Tier 2 parts of the Clouds so effectively, in my opinion, there is this [inaudible] where we discuss about the Edge to Sensors versus where we discuss Cloud. You have Sensors, Edge and then you have the Cloud.