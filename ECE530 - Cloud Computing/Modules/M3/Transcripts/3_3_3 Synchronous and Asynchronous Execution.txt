 >> So let's move on from the failure modes in the baseline failures to synchronous and asynchronous execution. I know we're getting a little deeper on some of the theoretical aspects of distributed systems, but I think these are foundational aspects when we think about Cloud computing. So let's look at three processes, p, q, and r. In this case, something happens from p, you have something that happens from r to q. Some data, let's say, being sent. In the synchronous model, messages arrive on time. Processes can serve like a synchronized clock. This is the synchronized clocks. For example, if a failure happened here, we can figure back whatever happened. But in the asynchronous model, none of this really holds because you don't have a centralized clock to effectively synchronize everything. So the thing is real distributed systems are not synchronous. They're asynchronous. You may have a central clock you monitor, let's you may have like a clock that you monitor all the instances, but the interaction with this clock may fail. But I said they're not asynchronous. Software often treats them as asynchronous. In reality, clocks can work in some times. In practice, we often use time cautiously. It can put limits on message delays. But in reality, it doesn't mean that clock always works well, but works most of the times well. For our purposes, we usually start with asynchronous model and the reason we do that is because it's better to start something that you know that may happen than with something than one that you're not guarantee is going to happen 100 percent. Subsequently, we enrich it with sources of time when useful. So that's what I mean. It's actually asynchronous, but if I can use sometimes the timer in some cases, O can have that bounded with a specific time, then I can use it. We sometimes assume a public key system. This let's us sign in or encrypt data where need arises. So Jill and Sam will meet for lunch. They'll eat in the cafeteria, unless both are sure that the weather is good. Jill's cubicle is inside, Sam will send an e-mail. Both have lots of meetings, so might not read the e-mail, she will acknowledge his message. They will meet inside if one or the other is away from their desk and misses the e-mail. Sam sees sun. Sends e-mail. Jill acknowledges. Can they meet outside? Well, the questions is, this is a common problem when we send messages, are we guaranteed that they will meet outside? So let's see. Sam sees the sun. Jill, the weather is beautiful outside, let's meet at the sandwich stand outside. I can hardly wait. I haven't seen the sun in weeks. Jill sends an acknowledgment, but does not know if, for example, Sam has read it. If I didn't get her acknowledgment, I'll assume she didn't get my e-mail. In that case, I will go to the cafeteria and she's uncertain, so she will meet me there. So you send a message, you get it back, you acknowledge, yes, great. See you there. Jill got acknowledgment, but she realizes that Sam won't be sure she got it being unsure he's in the same state as before. He will go to cafeteria, being dull and logical, and so she meets him there. Now, Jill sends an acknowledgment. Sam acknowledges the Ack, Jill sends acknowledges the Ack of the Ack. So effectively, what this means is that if we're to have a code system protocol after many interactions, everybody would acknowledge the other person so that you have a guaranteed that it has been received, and this can go effectively forever. Going back to this example, yes, great. See you there, but then Jill has to acknowledge that she has received the message and acknowledge, and acknowledge, and acknowledge. So suppose that noon arrives and Jill has sent her 117th acknowledgments. Should she assume that lunch is outside in the sun or inside cafeteria? What may happen is [LAUGHTER] you may get to the point where it's probably too late for lunch, so maybe tomorrow. The other aspect is that even if you set the sequence of messages, you don't know if the other person actually saved it. So we can't detect failures in a trustworthy, consistent manner. We cannot reach a state of common knowledge concerning something not agreed upon in the first place. We cannot guarantee agreement on things in a way certain to tolerate failures. So this is the bottom line. When do you send the message in the process in the Cloud service systems, it's extremely hard to assume that you can tolerate all the possible failures. You have to acknowledge that it will be [inaudible]. So going back to two-phase cubit and third-phase cubit. [inaudible]. Three-phase cubit is definitely better than two-phase cubit. In the real-world, a three-phase committees mostly costly extra, but blocks just the same. It can have it accurately. Failure detection. Failure detection tools could generally help, but the Cloud thread is in the opposite direction. Cloud transnational standard requests are inactive here. [inaudible] service, if it goes down, the Cloud transaction subsystem halts until it restarts. So bottom line, many systems that we will be using to face [inaudible] , but those early to terminate transactions in a transactional system. So this is what we'll be using as the best effort system. [NOISE]