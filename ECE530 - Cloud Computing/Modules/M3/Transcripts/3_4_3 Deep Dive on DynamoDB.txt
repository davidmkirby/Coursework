 >> Let's do a little deeper dive on the DynamoDB. We discussed about eventual consistency and how eventual consistency is being used in different areas from financial decisions to Amazon to Netflix, to really many and large companies even nowadays. Dynamo is the name given to a set of techniques that when taken together can form a highly available key-value structured storage system or else a distributed data store. It has properties of both a database and a distributed hash table. Let's get into more detail about that. Assuming that you want to represent something, like you want to buy walkie-talkie from Amazon. Amazon has a specific ID, an identifier like a number, that is associated with the specific walkie-talkie. So when you go and pay for a walkie-talkie, the E-system gets back with an ID and says, "Here's the ID of the walkie-talkie." Then you say, "Oh, give me the walkie-talkie." Then what you do is you do what we say, I get operation of the ID so that you can get the walkie-talkie. This is how effectively a hash table works and this how a key-value store works. So let's see the Amazon challenges. It's the largest e-commerce site in the world. It serves millions of customers, I mean close to billions, at peak usage time with using thousands servers in many data centers around the globe. Especially during peak operations, Amazon procures huge infrastructure to be able to help with the demand. Strict operations requirements on Amazon's platform in terms of performance, reliability, and efficiency. So a slight outage can have a significant impact on the financial consequences and impact to the customer trust. The first thing that you want to do is you want to make sure that your system is not down. If Amazon goes down, then people are going to start filling out, they will go on Twitter and start writing about that. They'll do the same when they go to Netflix or Facebook or any of these big platforms. Because as more and more the world becomes connected, we're very much dependent on them. Which means that whatever we design as a system has to be scalable. It has to support continuous growth of customers as they grow from a few thousands to millions of customers. This holds for effectively any consumer-oriented platform right now. Amazon uses a highly decentralized, loosely coupled, service oriented architecture consisting of hundreds to thousands of services, and all these services what they need, is they need to storage. So customers should be able to view and add items to their shopping cart even when disks are failing, or network routes are flapping, or even when data centers are destroyed because of tornadoes or even any other natural disaster. Then the service that is responsible for managing shopping carts requires that it can always write and read from that data store. So you can write means that you can add items to the shopping cart while reading means that you can read the shopping cart so you can check it out and pay for that. What is Dynamo? Dynamo was initially a highly available distributed key-value storage. So it has two interfaces, a put and a get. Put means that I will write some data. Get means I want to get some data. What it does, it sacrifices consistency for availability. If we go back to the cart filling, what we discussed was that it is an incredible and partition-tolerance system like an AP system. It provides storage for some of the Amazon's key products, like the shopping carts, bestseller lists, and so forth, and it uses a series of well-known techniques to achieve scalability and availability. Some of these techniques are, for example, consistent hashing, object versioning, conflict resolution. But what we are going to do, you can actually go and read the paper for Dynamo to get into the details about that. It is a set of techniques to form a distributed key-value structure system. After the Dynamo protocol was published in 2007, there were a few systems that were developed based on Dynamo. DynamoDB was one of them, Cassandra was another one, Facebook and so forth. There's maybe other database that where it came from that. The scale. Amazon is busy during holidays. Tens of millions of requests for three million checkouts in a single day. Session state about $100,000 of concurrent active sessions. So failure is not very common. Yet a small but significant amount of servers and network failures happen at all times. So customers should be able to view and add items to their shopping cart, as I said, even when we have these important disasters at even high-scale. The flexibility. We need to have minimal need for manual administration. So you cannot call somebody to fix an issue when I was almost out. It has to auto heal itself, its subsets. So nodes can be added or removed within the data system without manual partition or redistribution. So what happens when a node goes down, the data system could be able to sustain that. Applications can control availability, consistency, and cost-effectiveness. So can developers know this upfront? Can it be changed over time? The question is now, how do you propagate this back to the users effectively? So assumptions. Assumptions that the data which has a very small, very simple query model or I put and I get. The values, first of all, are about one megabyte of binary objects. Then no ACID properties. So we have weaker consistency, no isolation guarantees and single key updates. Efficiency. It has stringent latency requirements up to 9.9 percentile. So percentile vacancies are fixed personalities, half of the users like that. An IT person is like 90 percent of the users have been doing that, and 99.9 percentile means that 99.9 of the users are bigger especially sample. If we will say 99.9 percentile latencies are 50 milliseconds, that means that 99.9 percent of the users or requests are actually getting 50 milliseconds of latencies. Of course, that the deployment itself is done in a number of data centers. It's not a hostile environment where you don't have control. Security can be a little more relaxed or handled by another system itself. As we said, a Dynamo is an eventual consistent system. It has to be always writable. So whatever happens when somebody adds an object in the shopping cart, the object must be there. What it does, it pushes conflict resolution to the reads. So if two people add the same object, or for example, where two people are trying to check out the last object from Amazon, let's say the last cucumber. So what happens is both will add it, but at a later point of time, when they try to read it, it will say, "Oh, I'm sorry, somebody else had the cucumber, you cannot now check it out." It's application-driven conflict resolution. It merges conflict with some shopping cart or Dynamo enforces what we call last-writer-wins. So effectively, when two people try to buy a cucumber at the millisecond level, Amazon will try to say, "Oh, you know something? The customer Number 1 was the one that actually put it first." That's why it says last-writer-wins. So the question, does it work? Of course, it does work on a high scale like apples the user.