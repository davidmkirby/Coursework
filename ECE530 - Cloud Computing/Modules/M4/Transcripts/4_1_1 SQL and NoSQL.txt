 >> Welcome to the new module. Let us discuss the battle between SQL versus NoSQL. This is relational versus non-relational systems. One of the main things we need in any cloud computing environment is the ability to interact with some form of data storage, whether this is for airline reservations, bank accounts, scheduled pizza deliveries, and so forth. That means that as most of these platforms tend to become web right now, we need to support them by the ability to scale on the cloud as well. One of the primary design goals that we did in order to move to the cloud was because of the scalability. If we didn't care about scaling, we wouldn't have gone to the cloud. One of the reasons that we move to the cloud is because the cloud provides horizontal scalability, that means you can add more instances to scale your services. But even if you don't need to add more instances, you can improve your instance type so you can effectively vertically scale. Some of the things that in a physical infrastructure will actually require a total update of the infrastructure. Our cloud applications data harmony has to scale as well, which means that if we scale the computational part of our applications that is the services and microservices that the customer state to interact with but we don't scale the data, handling the aspect of that, that obviously we will get a bottleneck, and then that may not be a position we want to be. A very simple example here is if you scale your services that add information to the shop and cart in any of these shopping websites but they say, dive your database, that actually stores the data at the shopping cart does not scale, then the problem is that you cannot anymore scale your services. At the realm of these, there are effectively two storage kingdoms in the data systems. One is the non-relational systems and the other is the relational systems. NoSQL or SQL, you probably going to hear both terms interchangeably across these presentations. The common data structure in non-relational systems is blobs, tables and queues in your later phase, we are going to discuss these in detail. There is no consistent interface so which means that most of the vendors, they deploy their own interface on how one really access the database. They tend to scale very well, and the reason because of that it's actually they give up some of what we call the data integrity aspect. Most of these systems don't provide transactional guarantees, so whatever integrity the program requires is the responsibility of the program developer to deal with. If they don't need to get a transaction that the user has to deal with something with these capabilities. But this is what we need to give up and we discussed a few of these things in the CAP theorem was one. In the relational kingdom, there are classics table database like Oracle, Microsoft SQL, MariaDB, Postgres, and so forth. They provide data integrity services such as not allowing the customer to be deleted from a customer table as long as an order that order table references that customer. This is effectively the transaction. Once you have something that is pending you should not be able to delete something else. The support complex queries involving joins across tables, and this is one of the advantages of relational systems. Now you can actually have very complicate queries and effectively SQL became from a very simple language to a very complicated query language, because people will do very complicated queries to serve the business needs. It's harder to scale especially at multiple machines, and the main reason is because if you start scaling horizontally, you will start losing your single point of handling some of your transactions. Often they contain legacy data for applications that need to move to the cloud. At the real beef, we start comparing SQL versus NoSQL. We see that the non-relational database does not incorporate the table modeling. State data can be stored in a single file, in a blob, in a queue, or whatever it is. But in SQL space, you have a more stable structure and you can create relationships between those tables. For example, you can say, this is the product table, this is a prize table, and this is the ingredients so you can actually relate the information between themselves. Let's now discuss a very simple example of an SQL example. Assuming that you are creating a blog, the table for all your posts, each post in that table has a row, it all has something like a numeric idea that text of that post. This is an example of where you actually create a blog and its posts in that table is a row, and then you have an ID for each of the rows of that post. When you want to read the blog post, the URL in that address bar of your say something like give me this post number 1. You do a query says select everything from the posts with an ID equal to 1 and then you get back the first box. Once you get back effectively the software itself, the web browser renders HTML, and then it presents back that post. The relational model typically comes into play when you visit a blog that has some comments. That comments table will most likely have the same ID column and a column called body or something like that for storing text of the column. In a common thing is now you could create another table where that column table is now correlated with the post table, and then you can say, I won't let say post number 1, the column number 1. You say, select this comment from this table and then give it up sorry disposal off this table and give in the comment from the other table that you have established a relation between comments and posts. This table will also have a column called something like post ID and what gets stuffed in the column is the ID of the blog post that this column relates to. Effectively you create another, as we said, table, that within the information of the comment you have also the post ID, which backreferences the post table. Now when your reader comes by the blog software turns around to the database and asks for two things. Select everything from the post table 1 where the idea of the post is equal to 1, and select everything from the comments table where the post ID is equal to 1. Now the second query is if you are lucky enough to write something that people respond to, will return a list of comments, an array if you will, that your blog software will then convert to HTML and append to your blog post in the form of the comments section. So which means that you do a single query, HDB, your HTML that you respond back, is if it includes the blog post at the comments section associated with that. This is a great example for a blog and many blogs have actually designed like that because you don't have billions or trillions of comments or posts that have in the blogs. In the NoSQL, example is the request comes in blogging software turns around to database and says, please give me back the specific post, anything related to it. In this case, listing of comments, since we're not forced to be too uptight about having to define how the data is structured. What if we want to tag that post with an arbitrary number of categories? No problem, let's stick them on the same document and when block software says, give me everything you'll post to add, the tags, the comments, and any other randomly associated data come back with it. Effectively what we do is we can do a scan on the database says give me everything that relates to this specific worst. If you see in this example, obviously the table format fits a little better than let's say the blog format. This is one of the things that you need to identify how your data model is going to happen. In a grocery case, you can model the grocery list in a lot the same way, like a piece of paper you write the items you want on there. But let's say for the purpose of this example, you figure out after a couple of months that you want to keep track of how many loaves of bread you actually brought last year. Well, probably with the non-rational model you might literally have to go through every list and count each loaf individually whereas had you modeled this in a rational way, you could get that count back almost instantly. This is another inefficiency of NoSQL. If we tried to go back to SQL vs NoSQL, the pros is in relational data model is that it is easy to use and set up. It's universal. Everybody uses SQL model. Already started stated goal of stages or the query it may be tailored to the needs database. But fundamentally, the user doesn't really care about all these complexities. It's good at high-performance workloads, especially when you have high-performance meaning up to 10,000 or 20,000 writes per second but above that doesn't scale very well. It's good at structured data like tables and so forth. The SQL side of that, the glide-like collide with this type of technical shifted aside that decide the structure of the database. It is going to be difficult to scale. The process of the checklist there is no investment to date design model. You can wrap it developed over cycles. Generally the APIs, but even a simpler than SQL editor runs very well with the cloud because you cannot constantly take the schemas and you have no problem about that. But it [inaudible] says treated for interconnected data, what you need is effectively relations between tables, for example, say the blog and the comments. The technology still virtually there's a lot of systems out there but still virtually, it's going to have a slow response time in some cases but can scale with a lot of nodes when we add a lot of wiggling scale horizontally with a lot of nodes.