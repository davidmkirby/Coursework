 >> In this module, we'll cover a little about the non-relational models or else the NoSQL [NOISE]. NoSQL databases is any of the modern databases that essentially give up the ability to do joins in order to be able to avoid a huge monolith of tables and scale. Some of the examples are key-value stores like the Vanilla Dynamo paper in 2007 or even Redis which is a key-value store with a very simple API in advanced data structures. Some others include HBase and Cassandra. While you may think about that Cassandra was based on the Dynamo paper in terms of high dozen application, it does use coding family underneath it. Another flavor of a NoSQL database, is document-based. An example is MongoDB, which is one of the most actually famous NoSQL databases in the market. The NoSQL databases usually has some form of a flexible schema, that means there are no rigid tables and no rigid N by M structures that can be caused by joins across tables. Flexible schema means that at any point of time you can increase any of the fields or add new fields within the schema that you have. An example would be when you are trying to have let's say Amazon, represent a product and all of a sudden one day they decide to add some new field for example, the metadata of a specific product they can do that very flexibly within the NoSQL databases. Why NoSQL in the last five, six, maybe eight years has become a big market shift from the relational system. The problem was that within the Cloud era we see that the datasets started to become too big, having a single node that will accept all the data was not good enough. There are different ways that you can achieve scalability. [NOISE]. The reason this happened is because now you had hundreds of thousands of visitors in a short span and that is a massive increase in traffic within the database itself. Effectively, there are many part business started through that. One of them was microservices and the others is splitting the NoSQL data systems. Now developers begin to front RDBMS with read-only cache to offload a considerable amount of read traffic. This was the first level of redirection, but once you actually add some read only cache, let's memcache or Redis, the problem is you cannot anymore do transactions on the cache itself. Memcache or even integrated caching mechanism within the applications was another way you can achieve that. For example, you can have a huge house index within your applications, like a read memory index or distributed replicate that close objects over multiple nodes. But as data grow, the simple memcache/MySQL model for lower costs startup start to become fairly problematic because now you have lots of data, lots of traffic, and a single master-slave system was not good enough. The main objective of NoSQL is that ingestion of data that has unknown or undetermined structure. This is what we discussed before as the schema structure. It is relatively easy of scaling with increase volume and velocity of data because now you can add more nodes and horizontally scale your data systems. It has the ability to analyze large volumes of data significantly quicker than traditional SQL databases, and the reason is because once you have joins then you start doing scans across joins it becomes very problematic because of the nest things that you have within a database. In the NoSQL side, you don't really have nest thing. You have [inaudible] things, but you don't have joins, which makes it complicated. It again finally it provides the capabilities to derive value from data, whether it is big or large data. NoSQL is actually Not Only SQL. It provides Insert only no UPDATE/DELETE. There's no joins, thereby reducing query time. This involves de-normalizing the data. It does not support SQL. It supports the old like very bad vental driven Clyde protocols. It has no adherence to ACID properties like an atomicity consistency, isolation, durability, which actually makes a few things simpler but a few things a little more complicated. So SQL, not only SQL, is schema free, embraces de-normalization of data. It provides greater scaling capabilities. It has a very simple design. You don't really need to have advanced transaction, multithreaded support. No need to have advanced query ages. Storing objects that represent your domain. It gets great for unstructured or semi-structured data. So actually, when you don't need tables and rows, in unstructured form, that's where those SQL becomes very, very interesting as a product. The initial seeds of the NoSQL era started by Bigtable, which was one of the papers that Google wrote, the Dynamo paper that was published, which is a distributed key-value store. But also it was important that they included the gossip protocol which is subsets embedded with many other data systems like cassandra. The CAP theorem as was formalized by Eric Brewer and effectively it became loud between BASE and ACID, these two of these properties based on what he did. He did a base, NoSQL system or you did acid guarantees which you get from relational systems. One of the main issues of relational systems is of course that you can scale the RAM, you can scale the CPU, you can scale the hard drive but at the same time, this is called vertical scaling. At some point you actually hit a limit. On the Cloud what you really need to do most of the time is use your horizontal scale. You can add more hardware or more instances or more virtual machines, or even more containers in some cases to scale up your data systems and this is what we call horizontal scalability. With relational systems, you can only get with a vertical scaling. With low relations you can actually use horizontal scale and vertical scale as well. As we said, there are different flavors within the noSQL side. We move from the tables and rows. That also the corners like a tabular format to the analytical OLAP towards a key value called the family graph and document flavors. Of course, there are different types of databases that you could use. Here there's the column stores which have read and write extensions. Some of these are HBase and Cassandra. You have the document stores, which you have a significant blob of data that you would store, like sensation file, an example for those is Couchbase or MongoDB. Then you have graph databases where you have some complicated high level of nesting, which is like spatial data storage. Neo4j is actually the one which is the most popular one. Then you have auto key values those like Riak, Redis. Riak does not exist anymore which actually provides you to some of the high, very fast and very stable access mechanisms. [NOISE]. As we start to moving from relational to non relational SQL we see the traditional format schema of the data, where you have like a post id and the title. You don't have much flexibility. [inaudible] have a lot of flexibility. So in this case, you can have both post a title and a different types of comments. But then you can have also another post where instead of having the comments, the title too you actually have the images. This is what we call by flexible schema. You can save the schema based on what the application needs. Within a database, you can have, for example, the something that records the comments of a blog post, as well as the id's of the images that you can face from an objects thoughts. But whatever you move it comes with a few disadvantages. The fundamental disadvantage of NoSQL is lack of standardization, support, and maturity. Maturity is not that much of a problem anymore because some of these databases have increased in terms of maturity. Non relational database do not use a Structured Query Language, the SQL. There's no unified standard language it's either it uses it's own way to actually access the data. This makes it difficult to migrate the process over to a NoSQL. Actually, you don't only need to migrate the data, but you also need to modify the application. If you still use SQL database, as in you have written your application using SQL, which is just a common query for math of course, most of the systems whether to use MySQL or Postgres or any of these systems, the application does not really need to change substantially based on the data system. It has to change a little but not substantially. However, once you move to NoSQL systems like Cassandra has its own query language, they call its CQL, Cassandra Query Language, but I discuss its own language, Mencast has its own key-value APIs. Every one of them have their own APIs and clients. Some of the NoSQL database requires specialized expertise. For example, once you start scaling to like horizontal scaling to hundreds of nodes Cassandra it becomes very difficult. Whereas in actual database, you can have a DBA where the fundamental aspects remain the same across most systems. Then for many companies may fall in the trap of using Open Source S NoSQL. Because using an open-source on an NoSQL it's fast we can, and what you end up, when you become at scale, the problem becomes a little more complicated. Let's now see a little bit differences. Here we have on the left side that snippet of differences between SQL and NoSQL. Actually you can see the operations get a little more complex in the JSON format. Here, you can insert to a book these values whereas here you can do the same thing with adjacent document, which is okay, simply good. When you try to do an update, it's clear, it's an updates whereas here you have to do an update, you have to give the ISBN, you have to give the set, you have to give all of these properties in a select query, select title for a book where it becomes more natural to express that, compared to like expressing in this form of a JSON format. But there some advantages of NoSQL like flexibility which is easier to manage and more adapt at dealing with newer data models. Then for NoSQL can fit very specific needs of the company and it can be really faster to scale it up. It's highly scalable especially at low cost. Many NoSQL options are open source making them more affordable option for smaller organizations. You notice they speak in some of SQLs have the same [inaudible] like [inaudible] the DB or MySQL or Postgres. NoSQL options like Mongo or Amazon allow for big data processing at relative affordable price. SQL relies on proprietary servers and storage systems which end up becoming more expensive than a gigabyte or transaction cost of NoSQL. NoSQL databases can scale out as opposed to scaling up and we said because the vertical and horizontal scale. In the past database had relied on scaling up by buying bigger centers to have more data loads. Of course by larger and larger servers. The problem is that ones the NoSQL goes down you have to reelect a new bus that will help with the right traffic. The problem with that is that now, your dataset that is now dot-dot accessible, it's actually even higher. If you get up, when he got bored of beef to the system, you actually give up some more availability. NoSQL can scale out bidding the database will be distributed across multiple servers as load increases. Therefore, NoSQL databases are usually designed with low-cost commodity hardware in mind. You don't really need specialized counter for many of these systems.