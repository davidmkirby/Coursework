 >> Let's discuss about data pipeline with messaging system. In the previous section, we discussed about data pipeline without a messaging system. This is about data pipeline now with messaging system. Let's look at this picture again. Let's assume that we use a messaging system. In this case, we'll assume we use Kafka which is one of the most common messaging buses that exist in the industry. Of course, one may assume that we knew something else, but for the sake of this example, we're going to use Kafka. What we see is that all incoming data from all applications and services are writing data first to Kafka as a queue. What happens is all the consumers, that is the Hadoop, security, data warehouses, monitoring, or even different services are actually consuming the data out of the queue. In this example, what happens is now the communication between services becomes more natural and everything goes through the Satellite queuing system or messaging system. In this model, it's actually what we call a pub-sub model. When we have a number of publishers that they are publishing. let's say some letters, and then they go through the channel, through a stream, and then they're been delivered to subscribers. We can easily see the equivalence of that with how, for example, our postal system is working where people are putting the letters in folders, and then the folders are being delivered to a USPS or to private companies like UPS and FedEx. Then they are delivered to the subscribers. Messaging consists of effectively the producers, which are the ones that are generating the messages. The consumers which are the ones that consume the message generated by the producer and they consume the message out of queueing system or out of the messaging system. Now, between the producer and the consumer, there is a message broker, as we discussed, that is used to synchronize the messages between them. Of course what may happen is you may have producers that produce a message, and then there you may have many consumers of that message instead of just one and vice versa. You may have multiple producers and less consumers. The message broker performs the synchronization of messages with the help of queues which are used to add new messages or remove messages which are consumed. Mainly what is the backbone now discussing is what we call the data in transit. That is how services on the cloud are able to move messages and to move information between different types of services that need to consume those messages. In the messaging, there is this part which called the store and forward. The broker implements the store and forward mechanism to synchronize messages. The queue in the broker will store the messages until and unless some consumer consumes those messages. The consumer consumes the message process it and sends an acknowledgement to the message broker to indicate the successful delivery of the message. This is effectively, producer puts a message to the queue consumed by the queue then acknowledges that it has received effectively the message. In some sense, this is at least somebody or at least one consumer has acknowledged the message. In decoupling. Now the producers and consumers that are separate from each other and they involve decoupling to exchange messages with each other. In the decoupling aspect is that effectively, what we have achieved, is we have achieved that the complexity of the code that we build in the consumer and in the producer are totally separate. You don't have to effectively block one with another, because there's a centralized queuing system that can hold messages in some cases for hours or days. There are three types of decoupling, the Logical decoupling, the producers or consumers do not know anything about each other except the routing information, and this is actually really great. The physical decoupling in which the producer and consumers are even or different locations. Finally the temporal decoupling, the messages are consumed by the consumer at a later stage. As you can see in this we have achieved logical, physical, temporal is you have this separation of the consumer and the producer. This makes much easier the maintenance of the service. For example, if you didn't have a queuing system and you published a message and it was stuck, then it will affect some of the CPU cycles of the producer. Now because you have decoupled the consumer and the producer itself, now you're able to effectively isolate that. You can also isolate the failure debates in physical decoupling because the producer and consumer are even located in different locations. Temporal decoupling is also great because you can publish a message and you can say, "Oh the consumer is going to consume that after 24 hours or after 48 hours", where maybe a bunch of other messages have also taken place. In this case, we have the queues, which are of course, loosely coupled as we said. For controller A, the controller B, and controller C. The accuracy if you have a sequence of microservices talking to each other, we may have some blockage situation, whereas in this case, we'll have to have queues. You have a queue that tries the controller and consumes the message, put the message back to another queue, consumed by another controller and another queue. Effectively, we can have a system that can maintain a queue of messages without blocking the functionality of any of the controllers themselves. This is effectively loosely coupling.