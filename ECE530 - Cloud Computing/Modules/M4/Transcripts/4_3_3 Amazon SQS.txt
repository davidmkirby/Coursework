 >> Let us see now one of the main messaging systems that is provided by one of the Cloud vendor that is AWS and one of them is SQS. There are a few other ones like Kinesis, there is Kafka, RabbitMQ, there's a lot of them. But let's focus on this example now, and then we can do another few other examples later as well. Amazon Simple Queue Service, SQS is fast, scalable, and managed. Fast means that it can scale. So it can consume really fast some of the messages and managed means that AWS is taking care of the management of SQS. It enables asynchronous message-based communication between distributed components of an application. We discussed earlier about coupling of the set of system with cubic systems. So what can it do? SQS can decouple the components of a cloud application between the producers and the consumers. So you may have, producers producing messages that are being routed to the queue or multiple queues, and then consumers are contributing messages out of the queues. SQS can be used to transmit high volume of data without losing messages and does not require other services to be available. That means that if consumer is down, it can still keep the data within the queue. Once the consumer is up, then it can send the data to the consumer itself. These are example of an SQS where you have a Producer, that produces the data in a Master Queue. Then you have a Master Queue Order and then you have the consumers, which can be, for example, S3Q or Elastic Search Q or RDSQ. So what you do here is you fully decoupled the producers with the datastores that the data needs to be. If the data need to be let's say in a object store like S3, it's fully decoupled but will the data be consumed, let's say by Elastic Search or will it be consumed by relational database system like RDS. You also may build independent queuing systems within those subsets of systems as well. So this is an example use of Amazon SQS. You know, some of the major features that the SQS provides, and I'm confident that many queueing services also provide, is it provides the data infrastructure. So if something goes bad, you still are able to right with the queue. It provides multiple writers and readers. The reason you do that is because you need to have the ability to have multiple producers and multiple consumers but as well within a producer you got the issue that you could actually write the queue in a very fast, multi-threaded way. You can configure the setting per queue. That means you could configure the size of the key, and of course, as you can imagine the more data are being saved within the queue, the more you have to pay to AWS to host that SQS. At the same time though, it may be the case that you may want to actually hold 48 hours data before you write the through and many types have of these queuing services are used to generate financial reports. So you may want to wait until you have all the data but the same time you don't want to lose the data, so you write them to the queue. It's highly available, persistent and then its being consumed, that's my point. The messages can vary but, one of the issues that we have seen at least with a few users of SQS is that it has a message size of up to 256 kilobytes. That means your message size have to be fairly small, right. It provides access control, which means that now you can configure the security mechanism. This is actually part of the beautiful things about AWS, it provides integrations with many other services within the ecosystem. So access control becomes like the factor based on other services and it can also use delayed queues. So you can say publish this message after a specific amount of time, so this is a great feature actually. After a message is consumed from the queue, SQS does not delete the message. That is because the system is distributed, there is no guarantee that the component will actually receive the message and obviously SQS does not leave the message, and instead, your consuming component must delete the message from the queue after receiving and processing it. The reason you do that is because you want to decouple the consumer from the producers and at the same time you may want to have maybe multiple people that want to consume the message. So you may have multiple consumers. So if you have multiple consumers, and then one of them takes the lead to actually delete the message after it does some sort of form of coordination. So there's also something we call message visibility timeout. That means the amount of time that you can keep the message before it actually becomes non-visible. So we don't want all the components in the system receiving and processing the message again. In some cases, Amazon SQS blocks them with visibility timeout. It is a period of time during SQS prevents other consuming components from receiving and processing the message. Again, this is a very useful feature because you can actually say, I have consumed the message but I don't want anybody else to consume the message for the next, let's say five or ten seconds. So this can be done. So, this is a great feature that SQS provides. So let's discuss about message lifecycle. Component 1 sends a message A to the queue. So the queue has it. Component who retrieves the message A from the queue and sends the visibility timeout, period starts. Component 2 processes message A and then deletes it from the queue during the visibility timeout period, so what happens here is that you consume the message, you process it, and once you're at 3, now you can delete the message. So the fact that you have the ability to do, what we call a visibility timeout, means that you don't need to build coordination across all the consumers. Because [inaudible] two consumer receives the message, maybe its stuck processing the message but the processing is now decoupled from the consuming, which is really great because nobody else can consume the message so you don't have duplicate messages across different services. If this is the requirement, because [inaudible] requirement is for multiple consumers to consume the same message as well. So it depends on what you need. You can use the visibility timeout clock. You also have the ability to do what we call the delayed queues. Delayed queues allows you to postpone the delivery of the message in a queue for a specific number of seconds. For example, you can create a delayed queue, so any message that you send to that queue will be invisible to consumers for the duration of the delay period. So delayed queues are similar to visibility timeouts in that four features, make messages unavailable to consumers for a specific period of time. The difference, the difference between the two of them is that for delayed queues a message is hidden when it's first added to the queues. Whereas visibility timeouts, a message is hidden only when the message is retrieved from the queue. That means a delayed queue, you effectively delay the message to be visible within the queue. Whereas, in the visibility timeout you delay the message from being viewable to the consumers. So it basically is the same but it is different between each other because it affects the consumers versus the producers.