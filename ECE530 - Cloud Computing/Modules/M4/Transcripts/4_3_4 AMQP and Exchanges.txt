 >> Let us cover the last section, the RabbitMQ and exchanges. RabbitMQ is a mode, the AMQP model contains producers, consumers, exchanges, queues, bindings and message brokers. We covered about producers and consumers. Let's discuss about the exchanges, we discuss about queues and we discuss about message brokers. Exchanges, function as putting the messages received from the producer into the first queue present in the message broker. Exchanges is effectively part of the whole ecosystem. Now, queues buffer up the messages, until the consumer decides to fetch the messages. The link between exchange and the queue is called binding. Effective right now we are defining, exchanges, queues and binding. Again, exchanges function as putting the messages from the producer into the right queue. Queues buffer up the messages, until the consumer decides to fetch the messages. Binding is the link between the exchanges and the queues. There are three types of exchanges, which effectively tell us how the messages will be routed from the exchange to the queue. The first, is the fan-out exchange. In the fan-out exchange every message received from the producer is stored in all the queues present in the message broker. In the direct exchange, the messages are stored in a queue when the routing key provided by the producers matches the binding key of the queue. In the topic exchange, it involves the use of wildcard keys in order to store messages to a particular queue. Fan-out, direct and topic are the main three exchanges. We put messages to the queue. Fan-out exchanges, as we said, every message received from the producer is stored in all the queues. As you can see here, we have a message x, now this message is sent both the q1 and q2 and effectively is consumed by the consumers of each of the queues. Effectively this is more like, broadcasting a message across the queues. In the direct exchange, the messages are stored in a queue when the routing key is provided by the producer matches the binding key of the queue. Effectively, the producer itself includes a routing key, and the routing key is equal to the binding key, which means that, for a message x with a specific routing key, the producer now says, this could go to q1, or this is going to go to q2. The producer now does what we call a direct allocation of the message within the queues. That's why it's called the direct exchange. In the topic queue, is where effectively the producer says, "I have a set of topics and then I'm going to add information [NOISE] for each of the topics." The topic could be, for example, anything starting by "shape." will be in q1, anything starting with "shape -" is going to q2 and anything with just "shape" is going to q3. Effectively you can substitute the topics with specific dates that's represented. That's why it allows you to have specific topics, specific tools for specific [NOISE]. The retrofit use is described by the following three methods. The first is the transfer. The transfer takes place it to the ends of the queue. This is two-sided, consistent order of basis within the queue. The second is the browser. The best is stored in the queue are browsed from the side of the queue. This ensures a high amount of parallelism who are asking the messages from the queue and also shows very high throughput synchronization. Whenever a copy of queue present a message broker is created. It is that using a particular order or using the sequence number. It is similar to how the TCPI works, like TCPI uses also some forms of sequence numbers. This is another example of like messaging in the Cloud. When you have producers and consumers, you have messages, and you have queue. Effectively you are a service that does production, adds messages to the q and then consumes at a later point of time, and the you will have sales that have more consumers and producers and so forth. The q becomes this defacto pipeline between the services. How do you handle failures? There can be failures in effectively the number of loads and huddle in q or effectively in the brokers or in exchanges or anywhere. Failure to receive any acknowledgement from the broker, the producer will try to set the message again. It will retry the message, which may lead to duplication of messages. There is a potential for prospect of duplicate messages where consumers fails to acknowledge or processed messages, which is also known as redelivery. What happens if you have duplicate messages either at the production or at the processing of messages. One may cause the producer to resend the messages and the other may cause the redelivery of the messages to the consumer. What is certain to know, is about, even if these values you might have set like at least one delivery at the any common failures. But it's really hard to guarantee effectively ordinate.