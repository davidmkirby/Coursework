 >> So let us discuss now microservices. What does microservice means in the cloud framework, and how do you move from a service-oriented architecture which was the initial phases of the cloud towards a smaller and tinier components of the services which we call the microservices. Most [inaudible] resulted in the cloud native framework where effect of data, most of the things on the cloud like Netflix, they deploy hundreds of microservices on a daily basis. When it needs to actually try to create a framework that can showcase the interaction between microservices, it becomes this very strange eye. This is, for example, a depiction of the Netflix services ecosystem and all the interaction happen between different types of microservices. So back in the old days in the generation of the services, there used to be what we call monolythics. Monolythics is effectively where you have a single process, where you have all the business logic. Then as you try to replicate the process what you do is you now create the multiple servers. So this is how you scale it. If one of the servers goes down, we still have the rest of the servers. You've already have some load-balancing in front of that. At the same time they didn't all decreases, you can distribute like that. A Microsoft architecture, with its element or functionality though in each separate service. The reason we do that is because we are usually the ownership of each of the services, as well as the logic so that the one does not affect the other. When we try to scale microservices, we effectively scale all the sub-components. So you may have actually servers that may run two instances of the same microservice or more than that in some cases, as we saw like in this example here, in this example here, and in this example here. The microservices architectural style is when you develop a single application as a suit of small services, each running in its own process and communicating with lightweight mechanisms. One of them is the Rest API, more bot and communications are based on what we call GRPC, like our remote framework of communication. What we see here is effectively the software development lifecycle, HPLC. Where effectively you build the system and then you sip it, and then you write and then you do this feedback loop around and improve the system while interacting with action. What you have is you have some source, where it has a deployment distraction when we start discussing about containers that may be like a Dockerfile, that a single file includes that, then you have development, you have QA and CI/CD, this is effectively automated the deployments. QA is where you do like testing of the code. Now you need to adapt to different types of effectively platforms that you deploy that. These can be like a physical hardware where you need some infrastructure management and then you need some virtual machines, then on top of that you have different logic. You become like a visually deployment where you effectively have a cloud provider provides that and still use the virtual machines. In the microservices style, you can also scale between different kinds of clouds, but it is like global, this is like Google cloud or IBM cloud, or different types of other cloud providers. Why do we want to move from monolythics to microservices? That's because microservices allows us for what we call fast deployment. So when we make a code change in application for each service can be made independently, as long as we keep the API contract with the other services are the same. That means that effectively the build test deploy cycles that speeds up dramatically and at the same time, you can make changes as long as you don't violate the context. For example, Netflix deploys code a hundred times a day, thanks to the early adoption of microservices. [inaudible] with facebook recently they where moved from a monolythics to a microservice style. It ask for efficient scaling, this has loads of a microservice can be scaled independently. This is a much more efficient way of scaling application, because not every part of the application experiences the same amount of load and needs to be scaled equally. It also provides design autonomy. Developers get the freedom to employ different technologies, frameworks, and design patterns to design and implement each microservice. So that means that you don't have a single framework like a single line bits, but now anybody can deployed in their own way. At the end of the day, the interactions, the contracts, they remain the same. So in some cases, you move fast, you fail fast, and your failure is actually very small, because the only fail your own microservice in the whole ecosystem.