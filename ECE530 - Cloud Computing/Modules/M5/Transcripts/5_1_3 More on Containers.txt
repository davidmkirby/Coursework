 >> Let's go a little deeper in the containers. Why use containers? Obviously, once you deploy a container, you're built and deployed times decrease a lot. Because now you don't have to wait to spin up a virtual machine, which means that you don't have to wait to take some space for hard drive and allocate some memory, and all the computational intensive things that require to create a virtual machine. You can control the cost and smaller granularity because right now you're not really saying, "I'm going deploy on VM." But you have one VM and on top of that you can deploy 10 containers. You go at a much deeper granularity about how you can control the cost. Container technology simplifies cloud portability. So that means that you can run same application in different environments, which means that this is a big thing. With cloud providers, you're spinning up VMs. Now we're at a level higher, we're going into containers. If you have a container, you can move the containers between different cloud providers so they'll be between private and public clouds. It makes it very easy. Container encapsulates applications and define the interface with surrounding system. In a virtual machine, a full operating system installed with associated overhead of virtualized device drivers. This means that the virtual machine really need to get a specific [inaudible] system like an Ubuntu or CentOS, or even Windows. With a container, you only use part of this operating system. Container use and share the operating system and device driver of the host. Virtual machines have a full operating system with its own memory management. Containers share the host's operating system and therefore are much lighter. Let's go and see what's the difference between a virtual machine and a container. In a virtual machine, you have the visualization area or the server hardware. You can have the same container. You can have a host operating system. You can have a hypervisor, and on top of that you deploy the operating system. Like, you deploy another operating system on top of the host operating system. Then you have your binaries and libraries, and you have your application logic or your business logic here. Whereas in a container, what you have is you have the host operating system and you have some binaries and libraries that run on the same host operating system. On top of that, you have the application. So you effectively don't have a hypervisor layer which does a lot of translations. You directly [inaudible] slice and dice, the actual host operating system. Let's see what you can do in container. You can get an shell, you can own SSH in a container. You can own the process space. You can own the network interface. You can run as root. You can install packages and run a services. Let's see here what you cannot. You cannot use the host kernel that's because many containers use under the same host kernel. You cannot boot a different operating system. So your operating system and the kernel must be similar or the same along with what you deployed underneath that. You cannot have its own modules. You [inaudible] need the init the PID 1. Well, doesn't matter much for many people, but does matter for a few. Now, what's the difference between a container and a virtual machine? Let's see now the difference between a container and a process. Containers are processes with their full environment. A computer science textbook will define a process having its own address space, program, CPU state, and process table entry. The program text is actually memory mapped from the file system into the process address space and often consists of dozens of shared libraries in addition to the program itself, thus all these files are really part of the process. What we see here is, containers are processes in some sense. In this case in a container, same as every process, you take pieces of the memory and you tag them along. You take some other libraries and folders, and you actually put them in a container. How did containers start? Containers [inaudible] from the Linux container. It's a library called LXC, operating system level virtualization method from Linux. LXC is an OS virtual for running estimated Linux systems, container on a single control host. You have the Linux kernel which is a single- [inaudible] system. Then you have the kernel API which actually balances the containers, and then you have container management tools, which manages the high-level elements of the container. Within a container, you have different process and different name spaces. So effectively, this is the host operating system. These are the containers and these are the processes that you can write inside the containers. What do you have with elaborate system is the container management tools, which actually it's an application, it's not even within the operating system. Then the kernel API that the container management tool uses in order to leverage the containers. [NOISE]