 >> So fundamentals of cgroups. So the question that we're trying to run is, yes, container is, has been a recent trend within the cloud computing, but is it really a new thing? Cgroups, control groups, is a mechanism to control resources per hierarchical groups of processes. Cgroups, abbreviated from control groups, is a Linux kernel feature to limit, account and isolate resource usage of process groups. This work was started by engineers at Google 2006 under the name of process containers. In late 2007, it was renamed Control Groups due to the confusion caused by multiple meanings of the term container in the Linux kernel. It merged within the kernel version of Linux in 2.6.24. Since then, new features and controllers have been added. So what we see is that effectively the technology to enable containers has existed for about 15 years now. So cgroups design goals. The goals was to provide a unified interface to many different use cases, from controlling a single process to whole operating system level virtualization. Control groups provides resource limitation. That is, groups can be set not exceed a set of memory limit. This also includes file system cache. The original paper was presented at Linux Symposium and can be found at Containers. Challenges with the memory resource controller and its performance. Control groups also provide prioritization. Some groups may get a larger set of CPU or disk IO throughput. Accounting. To measure how much resources certain system use for billing purposes and control, freezing groups or checkpoint and restarting. So effectively, as you can see, this control groups is more like Linux library or a Linux kernel element, but allows you to control and slice and dice the operating system in a way that you believe it's going to be useful. Namespaces. The purpose of each namespace is to wrap particular global system resource in an abstraction that makes it appear to the processes within the namespace that they have their own isolated instance of the global resource. Control groups versus namespace. Control groups limits how much you can use. Namespaces limits how much you can see. So effectively with namespaces, you can have mnt, uts, ipc, net, pid, usr and you can only see that and you cannot see what other people are using. So you can effectively have your own mount with your own namespace, but you cannot see the namespaces the other mounts in different other namespaces. Let's now focus on the mount namespace. This is when you actually use the file system. The mount namespace isolates a set of file system mount points seen by a group of process. Processes in a different mount namespaces can have different view of the file system hierarchy. The mounts can be private or shared, and you can also have your own mount space, or you can even set it. The tasks running in each mount namespace doing mount/ unmount will not affect the file system layout on the other mount namespace. So here, in pictures, we have this mount and this mount, they mount to the same mount namespace, number 1, whereas in this one, it mounts with its own namespace. You can have effectively the user different types of mounts that they can use. Then you have IPC. IPC is inter-process. Inter-process namespace isolates the inter-process communication resources. A process or a group of processes have their own. So you can have your own namespace, you can have this as shared memory, semaphores and message queues. Then you can have the same within these two inter-processes with different namespace, but they don't communicate with each others. Containers use namespaces. So effectively now you can isolate the IPC. You can also isolate the file system as well. You can also isolate the network. So you can have a net namespace, isolate the network related resources. So you can have one namespace here, another and another. In end of the day they go under the global namespace and then they go under the same hardware. So you can still isolate it, but it depends on whether the hardware can support that isolation. So if one user uses, let's say you have 100 gigabit lead and one uses like 99 gigabytes per second, it will may congest the other ones. But from the point of the container itself, it does appear as a separate interface. So effectively you're creating virtual interfaces. You can also have process ID namespaces. Process ID namespace isolate Process ID, implemented as a hierarchy. So Process ID namespace is a hierarchy comprised of "Parent" and "Child". So you can have the parent namespace and you have the child namespaces. In this case, you can have for example, containers where they have their own PIDs, and you have also processes that are on the host operating system. So you can speed up, let's say an Ubuntu container and another Ubuntu container and there you can run their own process, isolate it from the operating system. But you can still run your own Process IDs within the operating system itself, as well. There are many other namespaces, like time-sharing system, UTS. Each process has a separate copy of the host name and NIS domain space so that's isolation. In containers useful for init and config scripts that tailor their actions based on namespace, you can have user namespace. So you can have different types of namespaces that effectively isolates the containers for one with each other.