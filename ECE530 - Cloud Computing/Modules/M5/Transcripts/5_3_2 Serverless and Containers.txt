 >> As we go deeper and deeper into the subject of serverless and containers, many of you will wonder. Now we learned a little about container management systems. We did introduction of serverless, where people can now speed up functions to do some work without really needing to understanding the inner pieces of a container ecosystem. How do you really compare those two? Let's take containers as an example. When you deploy a Docker container, let's assume you deploy that on AWS, on Amazon ECS, which is the service that Amazon provides for containers, you still need to think about the hosting cluster that your container will run on. You need to consider questions like: Which cluster will be best placed to run this container? Does this cluster have capacity for my container's resources like CPU and memory? If not, how should I expand the capacity? What is my strategy for deploying multiple instances of the container across multiple machines in the cluster? If the cluster has multiple types of machines within it, do I need to be concerned about when I choose my deployment strategy? What are the security constraints of the cluster, and do they need to be changed in order to properly host may container? So all of these items come to the picture when you start managing containers. You're not managing VMs, but you are going to managing containers. The benefits of serverless is that the hosting provider figures out all the allocate questions for you dynamically. So for example, they will speed up enough containers to run your function. They will do all this balance in the background without the application developer to need to know about the infrastructures, it becomes serverless. It guarantees that it will have enough capacity for your data. If it doesn't, it won't speed up the function. You don't have to spend money upfront over-provisioning your host environment. You do not have to spend money to maintain a container management system. So you're not be constrained down the road by under-provisioning the environment or over-provisioning at the same time. You're not paying for idle time. For example, your function has completed or your application has completed, now it doesn't have to be idle. Reliability, availability are also built it, so you don't have to think about these aspects when you actually speed up functions. By composing and combining different services together in a loose orchestration developers can now build complex systems very quickly, spend most of their time focusing on the business problem than focusing or maintaining infrastructure from VMs to containers. These serverless systems can scale, that they can grow, they can evolve without developers or solution architects, having to worry about remembering to patch the web server yet again. Now, you're focusing on the business logic than focusing on running a web server. For example, what happens if you talked at server which runs the web server goes down? You don't need to think about those items anymore because your service providers provides that. A good serverless architecture can speed up development time and help to produce a more robust product.