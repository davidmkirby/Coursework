 >> So let's go to another example, the Message Driven Serverless. Assume that you have a backend data-processing service, so your writing a user-centric application that needs to quickly respond to UI requests, but secondarily, you want to capture all the different types of activity that are occuring. So let's go to a more concrete example, an online advertisement system. When a user clicks on advertisement, you want to very quickly to redirect them to the target of the advertisement, but at the same time, you need to collect the fact that the click has happened so that you can charge the advertiser. Most famous web platform that you know right now, use are working like that. Whether this is Google or Facebook or other companies database. The revenue advertisements, they click, but they at the same time need to charge the advertiser for that revenue. In the very classical design, the advertisement server synchronously responds to the user. We don't care about that interaction for the sake of this example, but it also post a message to a channel that can be a synchronously processed by a click processor application that updates the derived database to decrement advertisements, the advertiser's budget or that a click has happened so that they can show statistics back through the advertiser. So this is a very well-known example that happens most advertisements websites. So now let's go and see what happened if we switch to advertisement with servers. In this case, competitive provision. The click processor will run as a function and then it will add every time there is a message in the queue. The change in architecture is much smaller here compared to our first example. This is why asynchronous message processing is very popular use case for serverless technologies. We've replaced a long-lived consumer application with a FaaS. This function runs within the event-driven context the vendor provides. Note that the cloud platform vendor supplies both the message broker we discussed and the FaaS environment. So the two systems are effectively close tied to each other. Fundamentally, FaaS is about running a backend code without managing your own service systems or your own long-lived linked server applications. That second clause, the long-lived sever applications, is a key difference when comparing with other modern architectural trends like containers or platform as a service. Now, if we go back to our previous example, the click-processing example, FaaS replaces the click-processing service, possibly a physical machine, but definitely specific application with something that doesn't really need a provisioned server, nor an application that is running all the time. So effectively, FaaS is when what runs at it real quick and added completed and move on. A second property of FaaS is that the FaaS offerings do not require coding to a specific framework or library. FaaS functions are regular applications when it comes to language or environment. For instance, you can speed up an AWS Lambda, whether this implemented JavaScript, Python, Go or any JVM language, or even any. Net language itself. Now the deployment is very different from traditional systems since we have no server applications to run ourselves. In a FaaS environment, we upload the code for our function to the FaaS provider, and the provided does everything else necessary for provisioning resources. That is, whether it is to instantiate a vision of a [inaudible] a process or something else that is really happened so that the FaaS can work properly. The third property is at horizontal scaling is completely automatic. It is elastic and it is managed by this provider. In more other resources you have to balance the scaling of the system. So if, for example, our system needs a 100 requests in parallel the provider will handle that without extra configuration on your part. The "compute containers" executing your functions are ephemeral. That is you should not store any data, with a FaaS provider creating and destroying the purely driven by us, the runtime really needs to do that. Now, most importantly, with FaaS the vendor handles all the resource provisioning and allocation. So there is no cluster VM, there is no Docker management. There is nothing that you need to do that for the container or the virtual machine itself. That's why it is focusing for the serverless idea. Now, if you want to read more resources, these are some great act, is actually some of the code that are within the slides can be retrieved from these resources, as well. There are a lot bodies resources if you want to contact me, I can send you a lot more. Thank you very much.